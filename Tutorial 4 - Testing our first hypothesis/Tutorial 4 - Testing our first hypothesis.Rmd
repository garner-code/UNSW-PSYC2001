---
title: "Tutorial 4 - Lets test our first hypothesis"
output: html_document
---

### **Checking installation and loading packages**

<!-- **Please make sure to click KNIT at the top of your screen. This will create a html file which presents a little bit nicer then the file you are seeing here :)** -->

As usual we first always check and load in our required packages. 

```{r checking and loading in packages, message = FALSE, warning= FALSE}
# Check if packages are installed, if not install.
if(!require(here)) install.packages('here') #checks if a package is installed and installs it if required.
if(!require(tidyverse)) install.packages('tidyverse')
if(!require(ggplot2)) install.packages('ggplot2')

library(here) #loads in the specified package
library(tidyverse)
library(ggplot2)
```

---

### **Developing our hypotheses**

Today we are going to address one of the key questions of the study about social media use – how does mood affect active social media use? Active social media use involves interacting with content (i.e. liking posts) rather than just observing posts.

There is some evidence to suggest that passive social media use is associated with lower mood in adolescents, whereas active social media use is related to positive mood [Dienlin & Johannes, 2020](https://pmc.ncbi.nlm.nih.gov/articles/PMC7366938/). However, a lot of the existing evidence comes from self-report, rather than measuring social media behaviour directly.

To address this question, the researchers used the participants metadata to count how frequently they liked posts. By cross-referencing this with the mood diary kept by each participant, they were able to calculate the average number of likes per 10 minutes of use when participants were in a good mood, and when they were in a bad mood.

---

### **Activity 1**

Based on the information above, discuss and formulate hypotheses around the following:

1. Should there be a difference in the number of likes between the mood conditions
2. What direction do you think this difference could be? Can you formulate an experimental hypothesis each way – i.e. good mood likes > bad mood likes, and vice versa?
3. What is the null hypothesis?

Discuss this with your neighbour and your tutor. Make sure you have clearly defined your hypotheses before moving forward.

---

### **Visualising our data**

First we want to load in the dataset that we need that is the `PSYC2001_social-media-data.csv` dataset. To do this we first load it in using the same`read.csv()` function combined with `here()`.

```{r reading in tutorial 2 data}
social_media <- read.csv(file = here("Data","PSYC2001_social-media-data.csv")) #reads in CSV files
```


Before we conduct any kind of statistical test it is a good idea to see how it looks. This will give us an understanding about the underlying data that is driving the results of our statistical test. Note: It is generally bad practice to go straight from the raw data to the results of a statistical test without first visualising the data. 


--- 

#### Density plot of the distribution

We can look at the distribution of the data using a density plot. A density plot is a smoothed version of a histogram which allows us to understand what the full dsitribution might look like if we had all the data in the world. More information [is here](https://www.data-to-viz.com/graph/density.html) if you are interested !

In order to make this easy to plot we first have to wrangle our data a bit. First we use the `select()` function which allows us to easily choose which columns we do (or don't) want to keep in our dataframe. Second we use the `pivot_longer()` function which allows us to combine different columns together. In the example below we take the columns ending with "likes" and put their values (i.e the number of likes) into the column "likes" and their names (i.e good or bad mood) into the column "mood". 

```{r Pivoting data}
social_media_likes <- social_media %>% 
  select("id","good_mood_likes","bad_mood_likes") %>% # choose which columns we want keep in our dataframe
  pivot_longer(cols = ends_with("likes"), names_to = "mood", values_to = "likes")
```

Now, we can get a density plot in R by using the `geom_density` function which inside the `ggplot()`.


```{r creating histograms for all samples, message = FALSE}

social_media_likes %>% 
ggplot(aes(x = likes, colour = mood)) +
  geom_density(linewidth = 2) +
    labs(x = "Number of likes", y = "Density") +
  theme_classic() #themes can be provided to ggplot which give it a bunch of aesthetics to change. One of these is theme_classic



```

You will notice that we are using a new function `theme_classic()`. This changes some of the aesthetics of the graph automatically so it looks a bit nicer. There are a bunch of other available themes [here](https://ggplot2.tidyverse.org/reference/ggtheme.html). 

You will also notice that we have a new argument inside our `aes()` function called `colour`. This argument tells `ggplot()` to use different line colours depending on the mood of the person at the time (i.e good or bad mood)

---

### Testing hypotheses manually

Now that we have had a look at the structure of our data we have have a go at using a t-test to compare the number of likes in a good and bad mood. We could of course do this manually, by hand (as we have in the tutorials). We have done this below using the first 10 values for good and bad mood likes. 

<br>

Thankfully, we have long since past the stone age so it is no longer necessary to do this by hand. We can get computers to do this for us! 

### Testing hypothesis using a two-sample t-test

We can very easily calculate a t-test in R using the `t.test()` function. Please first have a look at this function using the `?` to understand its arguments. While we usually put a code block here to do this we now recommend from now on instead using the console. 

<br>

We can see that `t.test()` takes a number of arguments which are important for the output of the test. What values you provide to these arguments is dependent on what kind of test you want to conduct. The `t.test()` function requires vector inputs (remember this means 'columns' from your dataframe) which we provide as the number of likes for good and bad mood using the original dataframe.

One of the most important arguments to fill in is the `paired` argument. This determines whether you are conducting an independent or paired samples t-test. Here, we have collected the number of likes for the same subject in different moods. This means this data comes from a repeated-measures design, and so a paired t-test is most appropriate. 

```{r conducting our t-test}
t.test(social_media$good_mood_likes, social_media$bad_mood_likes, paired = TRUE)
```

Discuss the output of this paired t-test with your neighbour and tutors. What does it tell us ?  

### **Activity 2**

Are you able to conduct a one-sample t-test using R ? Hint: You will need to use the `mutate()` function to create a difference column that can be input into `t.test()` as a one-sample t-test. 

```{r}
social_media_diff <- social_media %>% 
  mutate(likes_diff = good_mood_likes - bad_mood_likes) #first try to create a new column which is the difference between mood likes

t.test(social_media_diff$likes_diff) #put this column into the t.test function
```





### **Plotting our results**

Now that we have conducted our statistical test we need to present the results in the simplest way possible. One way to do this is by getting the avere number of likes when participants are in a good and bad mood and plotting it using a column graph.

To get the mean number of likes for each mood in a usable form (i.e a dataframe) we can use the `summarise()` function together with the `group_by()` function. The `group_by()` splits the data into different groups and the `summarise()` function calculates a statistic (i.e the mean number of likes)

```{r}
social_media_average <- social_media_likes %>% 
  group_by(mood) %>% #split the data by mood
  summarise(mean_likes = mean(likes)) #calculate the mean number of likes
```

### **Activity 3**

Are you able to plot this using the `geom_col()` function ? Hint: this will be very similar to the code above but instead using `geom_col()`.

```{r Column graph of likes}

social_media_average %>%   #write code that produces a column graph of likes with a different colour for each mood
ggplot(aes(y = mean_likes, x = mood, fill = mood)) +
  geom_col(linewidth = 2) +
    labs(x = "Number of likes", y = "Density") +
  theme_classic()

```

