---
title: "Tutorial 5 - Testing between groups"
output: html_document
---

This week, we are adding to our data analysis toolkit with a between groups analysis, using an independent samples t-test. But first, as always, data wrangling and visualization!

### **Quick links**

1.  [Visualising Data Distributions](#distribution_visualisation)
2.  [Testing Independent Hypotheses](#testing_hypotheses)
3.  [Visualising Confidence Intervals](#confidence_intervals)

### **Checking installation and loading packages**

As usual we first always check and load in our required packages.

```{r checking and loading in packages, message = FALSE, warning= FALSE}
# Check if packages are installed, if not install.
if(!require(here)) install.packages('here') #checks if a package is installed and installs it if required.
if(!require(tidyverse)) install.packages('tidyverse')
if(!require(ggplot2)) install.packages('ggplot2')

library(here) #loads in the specified package
library(tidyverse)
library(ggplot2)
```

------------------------------------------------------------------------

### **Testing between groups**

We observed last week how mood impacts active social media behaviour. However, that is not the only factor that influences social media use. For example, [Sapienza et al (2023)](https://academic.oup.com/pnasnexus/article/2/11/pgad357/7442564) found that people in rural areas are more likely to use their smartphone for social media and gaming, whereas urban dwellers are more likely to use their phone for navigation and business.

However, we do not know if people living in urban and rural areas engage with social media differently, regardless of how long they spend on their chosen platforms. Today we will address this question using the `urban`, `good_mood_likes`, `bad_mood_likes`, and `followers` variables. Remember, these variables stand for the following:

-   `urban` – urban (1) or rural (2) area (based on postcode density)
-   `good_mood_likes` – average number of likes made over 10 min during a good mood (from platform + diary)
-   `bad_mood_likes` – as above, but during bad mood
-   `followers` – average number of followers across platforms

------------------------------------------------------------------------

### **Activity 1 - Formulate your research question**

What do you think? Will urban and rural dwellers engage differently with social media? Will there be a difference in the number of likes made by people living in urban vs rural areas? Or in the number of followers people have in urban vs rural areas?

::: {style="border-left: 4px solid #9C27B0; background-color: #F3E5F5; padding: 10px; margin: 10px 0;"}
<strong>Question:</strong> What are the null hypotheses for your research questions (you should have one for ‘likes’ and one for ‘followers’? What would you expect to see if your prediction is correct? Discuss this with your neighbor and your tutor.
:::

::: {style="border-left: 4px solid #00bfa5; background-color: #e0f2f1; padding: 10px; margin: 10px 0;"}
<strong>Hint:</strong> We are going to average over the effect of mood, so we do not need to include mood in our predictions about likes.
:::

------------------------------------------------------------------------

### **Activity 2 - Creating our likes variable**

Today we will be averaging across mood to get the average number of likes for urban and rural dwellers. This means we first need to create a new variable called `likes` which is the average of the likes in a good and bad mood.

We first load in our`PSYC2001_social-media-data.csv` dataset.

```{r reading in tutorial 2 data}
social_media <- read.csv(file = here("Data","PSYC2001_social-media-data.csv")) #reads in CSV files
```

Lets double check its the data we think it is...

```{r check data}

head(social_media, 10) # you can even say how many lines you want to see! Try changing the number, and see what happens.
```

Are you able to fill the code below using the `mutate()` function to create this new 'likes' variable? Hint, the average of likes is `(good_mood_likes + bad_mood_likes)/2`.

```{r Activity 2}

social_media_likes <- social_media %>% 
  mutate(likes =(bad_mood_likes + good_mood_likes)/2 ) %>% #create a new column with specified values
  select(id, urban, likes, followers) #keep specified columns in dataframe

head(social_media_likes)

```

------------------------------------------------------------------------

### **Wrangling our data**

Now that we have this object it is important to check the format of the data. Lets use the `str()` function that we learned about in the second tutorial to do this.

```{r}
str(social_media_likes) #provides a summary of the data structure.
```

First we can see that having the values in `urban` are coded as either 1 (urban) or 2 (rural). Lets change this so that instead of using numbers we use the actual descriptions of urban and rural. It is surprisingly difficult to remember what 1 and 2 stand for once you come to look at your graphs. Life will be much easier if we can see what 1 and 2 stand for instead. To do this we will use the `mutate()` function with the `case_when()` function which replaces (or creates) specific values in a variable with new ones.

```{r}
social_media_likes <- social_media_likes %>% 
  mutate(urban = case_when(urban == 1 ~ "urban", 
                           urban == 2 ~ "rural")) #case_when uses if_else logic to replace values with specified values if the cases match.

str(social_media_likes)

```

We can see that `urban` is now classed as a `chr` (character) but we will eventually need to split our graphs by `urban`. This means that `urban` should be a factor instead. (Also, urban is a factor in the experiment, so there's also the reason of purism). Luckily, we can change this easily by using `as.factor()` within the `mutate()` function. The `as.factor()` function is used to convert other datatypes to factors !

```{r}
social_media_likes <- social_media_likes %>% 
  mutate(urban = as.factor(urban))

str(social_media_likes)
```

The data is now in a format that we should be able to easily visualise it and conduct our statistical tests. Well done !

```{r, echo=FALSE, out.width="50%", fig.align='center', fig.cap="Figure 1: What it feels like teaching this section"}
knitr::include_graphics("https://github.com/BsoCool/UNSW-PSYC2001/blob/main/Tutorial%205%20-%20Testing%20between%20groups/Figure%201%20-%20What%20it%20feels%20like%20to%20explain%20this%20section.gif?raw=true")
```

------------------------------------------------------------------------

### **Activity 3 - Visualising our data before analysis** {#distribution_visualisation}

We’re now going to look at the data in 2 ways. First, we’re going to look at how the data is distributed across all participants, so that we can check if the data meets our assumptions about normality. Second, we are going to plot our dependent variables (`likes`, `followers`) by group, to gain a visual understanding for what group differences might look like, if they exist.

Here, we create a density plot for `likes`. Note that we use a new argument here `linewidth` to control the size of the density line.

```{r Density plot of likes}
social_media_likes %>% 
  ggplot(aes(x = likes)) +
  geom_density(linewidth = 2, colour = "blue") + #the argument linewidth is used to alter the size of the density line. 
  labs(x = "Number of Likes", y = "Density") +
  theme_classic() 
```

Now, can you make a density plot for `followers`? Go on, you are a coder and you are strong.

```{r Density plot of followers}

social_media_likes %>% 
  ggplot(aes(x = followers)) + 
  geom_density(linewidth = 2, colour = "orange") +
  labs(x = "Number of followers", y = "Density") +
  theme_classic() 

```

::: {style="border-left: 4px solid #9C27B0; background-color: #F3E5F5; padding: 10px; margin: 10px 0;"}
<strong>Question:</strong> Do `likes` and `followers` look normally distributed to you? Why might the data be shaped how they are for each variable?
:::

::: {style="border-left: 4px solid #9C27B0; background-color: #F3E5F5; padding: 10px; margin: 10px 0;"}
<strong>Question:</strong> What impact does your new understanding of the data have on your analysis, if any?
:::

------------------------------------------------------------------------

### **Activity 4 - Visualising group differences**

Now we are going to make some density plots and boxplots, split by the urban factor so that we can see the group differences.

Are you able to help with this?

::: {style="border-left: 4px solid #00bfa5; background-color: #e0f2f1; padding: 10px; margin: 10px 0;"}
<strong>Hint:</strong> Use the `colour` argument in `aes()` to split the plot by `Urban`
:::

```{r Density plot likes split by urban}
social_media_likes %>% 
  ggplot(aes(x = likes, colour = urban)) +
  geom_density(linewidth = 2) +
  labs(x = "Number of Likes", y = "Density") +
  scale_colour_manual(values = c(rural = "purple", urban = "green")) + #manually define colours of specific parts of a graph
  theme_classic() 
```

```{r Density plot followers split by urban}
social_media_likes %>% 
  ggplot(aes(x = followers, colour = urban)) +
  geom_density(linewidth = 2) +
  labs(x = "Number of Followers", y = "Density") +
  scale_colour_manual(values = c(rural = "purple", urban = "green")) + #manually define colours of specific parts of a graph
  theme_classic() 
```

::: {style="border-left: 4px solid #2196F3; background-color: #E7F3FE; padding: 10px; margin: 10px 0;"}
<strong>Info:</strong> We are using a new function here called `scale_colour_manual()`. This allows you manually define the colours of specific parts of a graph. Here we have used it to define colours for specific groups.
:::

<br>

This is not the only way we may want to view the group differences in likes and followers. Using a grouped boxplot can be a handy way at looking at how groups differ from each other.

```{r Boxplot of likes split by urban}
social_media_likes %>% 
  ggplot(aes(y = likes, colour = urban, x = urban)) +
  geom_boxplot() +
  labs(x = " ", y = "Number of Likes") +
  scale_colour_manual(values = c(rural = "purple", urban = "green")) + #manually define colours of specific parts of a graph
  theme_classic() 

```

Can you change the code below so that the x-axis has a label, and the y-axis label is correct?

```{r Boxplot of followers split by urban}
social_media_likes %>% 
  ggplot(aes(y = followers, colour = urban, x = urban)) +
  geom_boxplot() +
  labs(x = "", y = "Number of Likes") +
  scale_colour_manual(values = c(rural = "purple", urban = "green")) + #manually define colours of specific parts of a graph
  theme_classic() 

```

::: {style="border-left: 4px solid #9C27B0; background-color: #F3E5F5; padding: 10px; margin: 10px 0;"}
<strong>Question:</strong> What do you think the data suggest about the group differences for `likes` and `followers`? Was it in-line with your predictions from activity 1? Are there any caveats or reasons to be cautious about your interpretations?
:::

------------------------------------------------------------------------

### **Independent samples t-test** {#testing_hypotheses}

We now want to learn whether we have evidence for differences between urban and rural dwellers on the 'likes' and 'followers' variables.

------------------------------------------------------------------------

### **Activity 5 - Undertaking an independent t-test**

Can you work out how to perform an independent samples t-test for these variables ?

::: {style="border-left: 4px solid #00bfa5; background-color: #e0f2f1; padding: 10px; margin: 10px 0;"}
<strong>Hint:</strong> Use the `t.test()` function from the tutorial last week and pay attention to the 'paired' argument !
:::

```{r}
t.test(formula = likes ~ urban, data = social_media_likes, var.equal = TRUE, paired = FALSE)
```

```{r}
t.test(formula = followers ~ urban, data = social_media_likes, var.equal = TRUE, paired = FALSE)
```

::: {style="border-left: 4px solid #9C27B0; background-color: #F3E5F5; padding: 10px; margin: 10px 0;"}
<strong>Question:</strong> Discuss the output of this independent t-tests, what does it tell you about the differences between urban and rural dwellers and how they use social media ? Is it what you expected when you formulated your hypotheses?
:::

```{r, echo=FALSE, out.width="50%", fig.align='center', fig.cap="Figure 2: Exams are hard"}
knitr::include_graphics("https://github.com/BsoCool/UNSW-PSYC2001/blob/main/Tutorial%205%20-%20Testing%20between%20groups/Figure%202%20-%20Exams%20are%20hard.jpg?raw=true")
```

------------------------------------------------------------------------

### **Extension - Visualising our confidence intervals ?** {#confidence_intervals}

This section is an extension activity if you have already finished the required materials. Please check with your tutor that you have a good grasp of the material before moving onto this section.

When performing statistical tests in the real world we sometimes want to visualise the range of our confidence intervals to inform us of the precision of our inferential estimates. Lets also include both measures of central tendency, the median and the mean on these visualisations.

Lets first extract the confidence interval and mean difference from our `t.test()` function for followers measure.

```{r}
results <- t.test(formula = followers ~ urban, data = social_media_likes, var.equal = TRUE, paired = FALSE)

confidence_interval <- abs(results$conf.int) # extract confidence interval

CI_upper <- confidence_interval[1]
CI_lower <- confidence_interval[2]

mean_difference <- abs(results$estimate[1] - results$estimate[2]) # extract and calculate mean difference 

```

Now lets calculate the median as this is not produced by the `t.test()` function.

```{r}
median_difference <- social_media_likes %>% 
  group_by(urban) %>% 
  summarise(median_followers = median(followers)) %>%
  summarise(diff = diff(median_followers)) %>%
  pull(diff)
```

Now lets combine all this data into a nice dataframe

```{r}
plot_data <- data.frame(
  mean_difference = c(mean_difference),
  median_difference = c(median_difference),
  lower = c(CI_lower),
  upper = c(CI_upper)
)




```

Lets now plot this using ggplot

```{r}
# Plot
ggplot(data = plot_data, aes(x = "followers")) +
  geom_point(aes(y = mean_difference), size = 4, colour = "green") +
  geom_point(aes(y = median_difference), size = 4, colour = "red") +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1, na.rm = TRUE) + #use to plot errors bars. Takes in two main arguments the upper and lower boundary of the error bar (ymin and ymax respecitvely !)
  labs(
    x = NULL,
    y = "Difference in Followers",
    title = "Mean and Median Differences in Followers by Urban Group",
    caption = "Mean includes 95% CI; Median shown without CI"
  ) +
  theme_minimal()

```

::: {style="border-left: 4px solid #9C27B0; background-color: #F3E5F5; padding: 10px; margin: 10px 0;"}
<strong>Question:</strong> How do these plots relate to the cavaets discussed earlier?
:::

Well done ! This computing tutorial is now over. Make sure to thank your tutor for another amazing class full of wonderful statistics and learning !

```{r, echo=FALSE, out.width="50%", fig.align='center', fig.cap="Figure 3: Everyone loves statistics ?)"}
knitr::include_graphics("https://github.com/BsoCool/UNSW-PSYC2001/blob/main/Tutorial%205%20-%20Testing%20between%20groups/Figure%203%20-%20Everyone%20loves%20statistics.jpg?raw=true")
```
